'''
Problem 1: Unique Word Abbreviation

An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:

a) it                      --> it    (no abbreviation)

     1
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
d) l|ocalizatio|n          --> l10n

    Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary.
    A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.

Example:
    Given dictionary = [ "deer", "door", "cake", "card" ]
    isUnique("dear") -> false
    isUnique("cart") -> true
    isUnique("cane") -> false
    isUnique("make") -> true
'''


class ValidWordAbbr(object):
    def __init__(self, dictionary):
        """
            :type dictionary: List[str]
        """
        self.dict = {}
        for w in dictionary:
            if len(w) >= 3:
                key = w[0]+str(len(w)-2)+w[-1]
                if self.dict.has_key(key):
                    self.dict[key].append(w)
                else:
                    self.dict[key] = [w]


    def isUnique(self, word):

        if len(word) < 3:
            return True
            
        key = word[0] + str(len(word)-2) + word[-1]
        if not self.dict.has_key(key): return True
        else: return word in self.dict[key] and len(self.dict[key]) <= 1
        
        


'''
Problem 2: Generalized Abbreviation

    Write a function to generate the generalized abbreviations of a word.
    
Example:
    Given word = "word", return the following list (order does not matter):
    ["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
'''

class Solution(object):
    def generateAbbreviations(self, word):
        """
            :type word: str
            :rtype: List[str]
            """
        def genAbbr(start, word, res, result, prevNum):
            if start == len(word):
                result.append(''.join(res[:]))
                return

            genAbbr(start+1, word, res+str(word[start]), result, False)
            if not prevNum:
                for length in range(1,len(word)-start+1): # replace 0, 1, 2, 3...all
                    genAbbr(start+length, word, res+str(length), result, True)
            return


        result = []
        genAbbr(0, word, '', result, False)
        return result    
        
        
        
        
'''
Problem 3: Valid Word Abbreviation

Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.

A string such as "word" contains only the following valid abbreviations:
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

Notice that only the above abbreviations are valid abbreviations of the string "word". Any other string is not a valid abbreviation of "word".

Note: Assume s contains only lowercase letters and abbr contains only lowercase letters and digits.

Example 1:
Given s = "internationalization", abbr = "i12iz4n":
Return true.

Example 2:
Given s = "apple", abbr = "a2e":
Return false.
'''


class Solution(object):
    def validWordAbbreviation(self, word, abbr):
        """
        :type word: str
        :type abbr: str
        :rtype: bool
        """
        size = len(word)
        cnt = loc = 0
        for w in abbr:
            if w.isdigit():
                if w == '0' and cnt == 0:
                    return False
                cnt = cnt * 10 + int(w)
            else:
                loc += cnt
                cnt = 0
                if loc >= size or word[loc] != w:
                    return False
                loc += 1
        return loc + cnt == size
        
        


'''
Problem 4: Minimum Unique Word Abbreviation

A string such as "word" contains the following abbreviations:
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

Given a target string and a set of strings in a dictionary, find an abbreviation of this target string with the smallest 
possible length such that it does not conflict with abbreviations of the strings in the dictionary.
Each number or letter in the abbreviation is considered length = 1. For example, the abbreviation "a32bc" has length = 4.

Note:
In the case of multiple answers as shown in the second example below, you may return any one of them.
Assume length of target string = m, and dictionary size = n. You may assume that m ≤ 21, n ≤ 1000, and log2(n) + m ≤ 20.

Examples:
"apple", ["blade"] -> "a4" (because "5" or "4e" conflicts with "blade")
"apple", ["plain", "amber", "blade"] -> "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").
'''

'''
Solution: DFS + 剪枝

首先将dictionary中长度与target不同的单词去掉。
DFS从空字符串''出发，逐一增加target中的字母；并尝试越过一些字母，插入数字。
遍历dictionary中的单词，检测冲突，若不存在冲突，则递归，并更新最优解。
剪枝策略：利用变量length记录当前时刻的最优的单词缩写长度，若DFS分支的长度大于length，则可剪枝。
'''

class Solution(object):
    def minAbbreviation(self, target, dictionary):

        def validWordAbbreviation(word, abbr):
            size = len(word)
            cnt = loc = 0
            for w in abbr:
                if w.isdigit():
                    if w == '0' and cnt == 0:
                        return False
                    cnt = cnt * 10 + int(w)
                else:
                    loc += cnt
                    cnt = 0
                    if loc >= size or word[loc] != w:
                        return False
                    loc += 1
            return loc + cnt == size


        def dfs(target, index, length, abbr, result):
            if length >= self.minLength: return
            if index == len(target):
                for word in self.dlist:
                    if validWordAbbreviation(word, abbr):
                        return
                result[0] = abbr
                self.minLength = length
                return
            dfs(target, index + 1, length + 1, abbr + target[index], result)
            if index == 0 or not abbr[-1].isdigit():
                for x in range(2, len(target) - index + 1):
                    dfs(target, index + x, length + 1, abbr + str(x), result)


        self.dlist = [d for d in dictionary if len(d) == len(target)]
        self.minLength = len(target)
        result = [target]
        dfs(target, 0, 0, '', result)
        return result[0]
