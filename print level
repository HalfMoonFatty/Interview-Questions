'''
Problem:

Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example: Given binary tree {3,9,20,#,#,15,7},
      3
     / \
    9   20
       /  \
      15   7

return its bottom-up level order traversal as:
[
[15,7],
[9,20],
[3]
]
'''

class Solution(object):
    def levelOrderBottom(self, root):
        def helper(root,level,result):
            if not root: return
            
            if level == len(result):
                result.insert(0,[])

            result[len(result)-level-1].append(root.val)    # note
            helper(root.left,level+1,result)
            helper(root.right,level+1,result)
            return

        result = []
        helper(root,0,result)
        return result
        
        

'''
Problem:

Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.
Example: Given binary tree
        1
       / \
      2   3
     / \
    4  5
    Returns [4, 5, 3], [2], [1].
    Explanation:
    1. Removing the leaves [4, 5, 3] would result in this tree:
      1
     /
    2
    2. Now removing the leaf [2] would result in this tree:
    1
    3. Now removing the leaf [1] would result in the empty tree:
    []
    Returns [4, 5, 3], [2], [1].  
'''


# Solution: 利用求height的题，piggback一个result 来填。

class Solution(object):
    def findLeaves(self, root):
        def dfs(root, result):
            if not root: return -1

            height = 1 + max(dfs(root.left,result),dfs(root.right,result))

            if len(result) == height:
                result.append([])
            result[height].append(root.val)
            # root.left = root.right = None
            return height

        result = []
        dfs(root, result)
        return result
        
