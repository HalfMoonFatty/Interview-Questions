* Knapsack Problem:

	- 单次选择+最大价值
	- 重复选择+最大价值

	- 单次选择+装满可能性总数   
	- 重复选择+唯一排列+装满可能性总数
	- 重复选择+不同排列+装满可能性总数



* String Matching:

	- Wildcard Matching 	
		if p[j-1] != '*': dp[i][j] = dp[i-1][j-1] and (p[j-1] == s[i-1] or p[j-1] == '?')
                else: dp[i][j] = dp[i][j-1] or dp[i-1][j]
		
	- Regular Express Matching
	 	if p[j-1] != '*': dp[i][j] = dp[i-1][j-1] and (p[j-1] == s[i-1] or p[j-1] == '.')
                else: dp[i][j] = dp[i][j-2] or (p[j-2] == s[i-1] or p[j-2] == '.') and dp[i-1][j]
		
	- Edit Distance
		if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1]
                else: dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)
		
	- Interleaving String
		dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])
		
	- Distinct Subsequence
		if t[i-1] != s[j-1]: dp[i][j] = dp[i][j-1]
                else: dp[i][j] = dp[i][j-1] + dp[i-1][j-1]



* Partition Array / String <Recursion>:
	
	- Break string S into words in Dict
	- Partition string S to be palindrome

	for i in range(1, n+1):
		for j in range(i-1,-1,-1):


* Longest / Largest Sequence:
	
	- Longest Valid Parentheses
	- Longest Palindromic Subsequence
	- Longest Wiggle Subsequence
	- Larget Subset Si % Sj == 0 or Sj % Si == 0
	- LIS 1D/2D (LCS)
	- Number of Arithmetic Slice


* Growing Intervals:
	
	- Burst Ballons
	- Guess Number (min of max)
	- Shortest Encode String
